---
title: newgamedev를 위한 테스트 페이지
date: 2018-12-22
lang: kr
ref: test-page
tags:
- tutorial
interactive: true
threejs: true
shader: true
---

newgamedev.github.io에 포스팅 하기위한 테스트 
## 시작하면서
많은 게임 개발자들이 현세대 게임에서 라이팅이 굉장히 복잡하다고 생각하고 있다.
허나, 예전이나 지금이나 사용하는 게임 라이팅은 똑같다. 렌더링 방정식을 기반으로 
게임 출시에 맞춰서 그 세대 하드웨어 사양에 맞게 만들뿐이다.

이런 것들에 대해서 이야기 하고 싶다.

## 렌더링 방정식
렌더링의 방정식은 1986년 James Kajiya가 발표하였고 Path Tracing을 방정식의 필수 근사치나 수치 해석을 위한 알고리즘으로 도입하였다.
10년 후 Lafortune은 양방향성 Path Tracing을 포함한 많은 개선 방안을 제시했고, 큰 환경에서 라이트 배치하는 등 어려운 장면에서의 성능을 높이기 위한 시도로 이어진다.

James Kajiya의 렌더링 방적식은 다음과 같은 빛이 3가지 특징을 지킨다.
1.GI의 원리
2.Equivalence의 원리(반사된 빛은 방출되는 빛과 동일)
3.Direction의 원리(반사된 빛과 산란된 빛은 방향을 가짐)

렌더링 방정식은 아래와 같다.

<script type="math/tex; mode=display">
\int_0^1 x^2 \, dx
</script>

<script type="math/tex; mode=display">
\varepsilon = \sum_{i=1}^{n-1} \frac1{\Delta x}
  \int\limits_{x_i}^{x_{i+1}} \left\{
    \frac1{\Delta x}\big[
      (x_{i+1}-x)y_i^\ast+(x-x_i)y_{i+1}^\ast
    \big]-f(x)
  \right\}^2dx
</script>

### BRDF

### Light Transfer

### Making It Game Lighting

## Test shader1
<div>
<textarea class='codeeditor fragment hidden'>
uniform vec2 resolution;
uniform float time;
        
vec3 background(vec3 light, vec3 rd)
{
	float sun = max(0.0, dot(rd, light));
	float sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));
	float ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));
	return 
		(pow(sun, 256.0)+0.2*pow(sun, 2.0))*vec3(2.0, 1.6, 1.0) +
		pow(ground, 0.5)*vec3(0.4, 0.3, 0.2) +
		pow(sky, 1.0)*vec3(0.5, 0.6, 0.7);
}

vec3 Light(float iTime)
{
    return normalize(vec3(sin(iTime), 0.6, cos(iTime)));
}

void main() {
    vec2 uv = 2.0 * (gl_FragCoord.xy / resolution.xy) -1.0;
    vec3 ray = vec3(0.0, 0.0, -3.0);    
    vec3 direction = normalize(vec3(uv, 1.0));      
    vec3 Light = Light(time);
    vec3 col = background(Light, direction);
     
    // Output to screen
    gl_FragColor = vec4(vec3(col), 1.0);
}
</textarea>
</div>

## Test shader2
<div>
    <textarea class='codeeditor fragment hidden'>
uniform vec2 resolution;
uniform float time;
void main() {
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4));
    gl_FragColor = vec4(vec3(col), 1.0);
}</textarea>
</div>

## Test shader3
```html
<div>
    <textarea class='codeeditor fragment hidden'>
uniform vec2 resolution;
uniform float time;
void main() {
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4));
    gl_FragColor = vec4(vec3(col), 1.0);
}</textarea>
</div>
```

<div>
    <textarea class='codeeditor fragment hidden'>
uniform vec2 resolution;
uniform float time;
void main() {
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    vec3 col = 0.5 + 0.5*cos(time+uv.xyx+vec3(0,2,4));
    gl_FragColor = vec4(vec3(col), 1.0);
}
